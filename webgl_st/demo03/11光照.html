<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>光照</title>
</head>
<body onload="main()">
    <canvas id="c" width="400" height="400"></canvas>
</body>
<script type="text/javascript" src="lib/webgl-utils.js"></script>
<script type="text/javascript" src="lib/m4.js"></script>
<script type="text/javascript" src="lib/primitives.js"></script>
<script type="notjs" id="vertex-shader-3d">
    attribute vec4 a_position;
    //uniform vec4 u_baseColor;
    attribute vec4 a_baseColor;
    varying vec4 v_baseColor;
    uniform mat4 u_mvpMatrix;
    void main(){
        gl_Position = u_mvpMatrix * a_position;
        //gl_Position = a_position;
        gl_PointSize = 5.0;
        v_baseColor = a_baseColor;
    }
</script>
<script type="notjs" id="fragement-shader-3d">
    precision mediump float;
    varying vec4 v_baseColor;
    void main() {
        gl_FragColor = v_baseColor;
    }
</script>
<script type="text/javascript">
    var modelRotator = [0, 0, 0];
    function main(){
        var canvas = document.getElementById("c");
        var gl = canvas.getContext("webgl");

        setupEvent();

        var program = webglUtils.createProgramFromScripts(gl, ["vertex-shader-3d", "fragement-shader-3d"]);
        var a_position = gl.getAttribLocation(program, "a_position");
        //var u_baseColor = gl.getUniformLocation(program, "u_baseColor");
        var a_baseColor = gl.getAttribLocation(program, "a_baseColor");
        var u_mvpMatrix = gl.getUniformLocation(program, "u_mvpMatrix");

        var positionBuffer = gl.createBuffer();
        var n = setGeometry();

        var colorBuffer = gl.createBuffer();
        setColor();

        render();

        //渲染
        function render(){
            webglUtils.resizeCanvasToDisplaySize(gl.canvas);
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            //遮挡面剔除
            gl.enable(gl.CULL_FACE);
            gl.enable(gl.DEPTH_TEST);

            gl.useProgram(program);

            //mvp
            var near = -100;
            var far = 400;
            var projectMatrix = m4.orthographic(-gl.canvas.clientWidth, gl.canvas.clientWidth, -gl.canvas.clientHeight, gl.canvas.clientHeight, near, far);//p
            var cameraPos = [0, 0, 200];
            var target = [0.0, 0.0, 0.0];
            var up = [0, 1, 0];
            var cameraMatrix = m4.lookAt(cameraPos, target, up);
            var viewMatrix = m4.inverse(cameraMatrix);//v
            var modelMatrix = m4.identity();//m
            modelMatrix = m4.xRotate(modelMatrix, modelRotator[0]);
            modelMatrix = m4.yRotate(modelMatrix, modelRotator[1]);
            modelMatrix = m4.zRotate(modelMatrix, modelRotator[2]);
            var mvpMatrix = m4.multiply(projectMatrix, viewMatrix);
            mvpMatrix = m4.multiply(mvpMatrix, modelMatrix);
            gl.uniformMatrix4fv(u_mvpMatrix, false, mvpMatrix);

            gl.enableVertexAttribArray(a_position);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);

            gl.enableVertexAttribArray(a_baseColor);
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.vertexAttribPointer(a_baseColor, 3, gl.UNSIGNED_BYTE, true, 0, 0);

            //gl.uniform4fv(u_baseColor, [0.2, 1, 0.2, 1]);


            gl.drawArrays(gl.TRIANGLES, 0, n);
            //gl.drawElements(gl.TRIANGLES, indicesLen, gl.UNSIGNED_BYTE, 0);
        }

        //几何体
        function setGeometry() {
            // Create a cube
            //    v6----- v5
            //   /|      /|
            //  v1------v0|
            //  | |     | |
            //  | |v7---|-|v4
            //  |/      |/
            //  v2------v3
            // 0, 1, 2,   0, 2, 3,    // 前
            //     0, 3, 4,   0, 4, 5,    // 右
            //     0, 5, 6,   0, 6, 1,    // 上
            //     1, 6, 7,   1, 7, 2,    // 左
            //     7, 4, 3,   7, 3, 2,    // 下
            //     4, 7, 6,   4, 6, 5     // 后

            var positions = [
                // v0-v1-v2-v3 front
                50, 50, 50,//0
                -50,50,50,//1
                -50,-50,50,//2
                50,50,50,//0
                -50,-50,50,//2
                50,-50,50,//3

                // v0-v3-v4-v5 right
                50, 50, 50,//0
                50,-50,50,//3
                50, 50, -50,//4
                50, 50, -50,//0
                50,-50,50,//4
                50,-50,-50,//5

                // v0-v5-v6-v1 up
                50, 50, 50,//0
                50,50,-50,//5
                -50,50,-50,//6
                50, 50, 50,//0
                -50,50,-50,//6
                -50,50,50,//1

                // v1-v6-v7-v2 left
                -50, 50, 50,//1
                -50, 50, -50,//6
                -50,-50, -50,//7
                -50, 50, 50,//1
                -50,-50, -50,//7
                -50,-50,50,//2

                // v7-v4-v3-v2 bottom
                -50,-50,-50,//7
                50,-50,-50,//4
                50,-50,50,//3
                -50,-50,-50,//7
                50,-50,50,//3
                -50,-50,50,//2

                // v4-v7-v6-v5 back
                50,-50,-50,//4
                -50,-50,-50,//7
                -50, 50, -50,//6
                50,-50,-50,//4
                -50, 50, -50,//6
                50,50,-50,//5
            ];
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
            return 6 * 6;
        }

        function setColor(){
            var colors = [
                // front
                255,  0, 0,
                255,  0, 0,
                255,  0, 0,
                255,  0, 0,
                255,  0, 0,
                255,  0, 0,


                // right
                0,  255, 0,
                0,  255, 0,
                0,  255, 0,
                0,  255, 0,
                0,  255, 0,
                0,  255, 0,

                // top
                0,  0, 255,
                0,  0, 255,
                0,  0, 255,
                0,  0, 255,
                0,  0, 255,
                0,  0, 255,

                //left
                255,  255, 0,
                255,  255, 0,
                255,  255, 0,
                255,  255, 0,
                255,  255, 0,
                255,  255, 0,

                //bottom
                255,  0, 255,
                255,  0, 255,
                255,  0, 255,
                255,  0, 255,
                255,  0, 255,
                255,  0, 255,

                //back
                0,  255, 255,
                0,  255, 255,
                0,  255, 255,
                0,  255, 255,
                0,  255, 255,
                0,  255, 255,
            ];

            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Uint8Array(colors), gl.STATIC_DRAW);
        }

        //立方体
        function setCube(){
            var cubeVerticeInfo = primitives.createCubeVertices(10);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, cubeVerticeInfo.position, gl.STATIC_DRAW);

            var indicesBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indicesBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cubeVerticeInfo.indices, gl.STATIC_DRAW);
            return cubeVerticeInfo.indices.length;
        }

        //事件绑定
        function setupEvent(){
            document.onkeydown = function (event) {
                switch (event.keyCode) {
                    case 65:
                        yAxis(-0.1);
                        break;
                    case 68:
                        yAxis(0.1);
                        break;
                    case 87:
                        xAxis(-0.1);
                        break;
                    case 83:
                        xAxis(0.1);
                        break;
                    default:return;
                }
            };
        }

        function yAxis(value){
            modelRotator[1] += radians(-(value * 50) % 360);
            render();
        }

        function xAxis(value){
            modelRotator[0] += radians(-(value * 50) % 360);
            render();
        }
    }

    //角度转弧度
    function radians(degree){
        return degree * Math.PI / 180;
    }

    //弧度转角度
    function degree(radians){
        return radians * 180 / Math.PI;
    }
</script>
</html>























